/*
======================================

Authors: 	Yuxin Li
Date: 	2023/12/17      

*/

theory diffMenero
begin

// 假设G是一个已知的椭圆曲线参数，Hs和Hp是哈希函数。
// A = pk(a)   <===>   A = a*G
// deskey      <===>   P = Hs(rA)*G + B
// tx          <===>   tx的参数包括本次交易的一次性地址、随机产生的交易私钥、环签名，、环签名产生的密钥像。
// deskeyver   <===>   如果 a*R = a*(r*G) = r*A，交易的接收者验证并构造P' = Hs(aR)*G + B = P
// spendkey    <===>   用户一旦获得utxo，他可以用x = Hs(rA) + b消费，如果他知道（a,b);
// rsign       <===>   用户至少知道一个私钥x = Hs(aR) + b,utxo_P = x*G,一个公钥集合含有n个公钥，攻击者无法知道Pi，
//                     rsign(x, Pi, P1...Pn, m) 包含n + 3 参数, 本文使 n = 2
// publicPKS   <===>   简化作用的析构函数
functions: pk/1, deskey/3, tx/4, R/1, deskeyver/3,
           true/0, spendkey/3, rsign/5, publicPKS/1

equations:
    // Given deskey & R, one can verify whether a utxo belongs to himself with a, which is half of the secret-key pair
    deskeyver(deskey(r, pk(a), pk(b)), a, R(r)) = true,

    // get the public-key set of a given ring-signature
    publicPKS(rsign(x, P, p1, p2, m)) = <p1, p2>

restriction DestinationKey_verify_true:
  " All x y #i. Eq(x, y) @#i ==> x = y "

restriction Diff_deskey:
  " All x y #i. Neq(x, y) @#i ==> (¬(x = y)) "

restriction Only_one_u1:
  " All #i #j. Only_one_u1() @#i & Only_one_u1() @#j ==> #i = #j "

restriction Only_one_u2:
  " All #i #j. Only_one_u2() @#i & Only_one_u2() @#j ==> #i = #j "

restriction Only_one_r2:
  " All #i #j. Only_one_r2() @#i & Only_one_r2() @#j ==> #i = #j "

restriction Only_one_r:
  " All #i #j. Only_one_r() @#i & Only_one_r() @#j ==> #i = #j "


// rule
// 
// To show the lying observational equivalence attack
// we let user u1 start a transaction to r
// LHS : take P which was generated by u1 himself as a trusted public parameter, that means P won't be learn by adversary
// RHS : take P which was listened from the public channel as public parameter as 

/*
====================================================
=                                                  =
=               Generate user                      =
=                                                  =
====================================================
*/
rule Generate_user1_to_be_observed:
    // private user key
    [ Fr(~a), Fr(~b) ]
  --[Only_one_u1()]->
    [ !SkPair(<~a, ~b, 'u1'>), !PkPair(<pk(~a), pk(~b), 'u1'>) ]

// generate common user
rule Generate_user2:
    // private user key
    [ Fr(~a), Fr(~b) ]
  --[Only_one_u2()]->
    [ !SkPair(<~a, ~b, 'u2'>), !PkPair(<pk(~a), pk(~b), 'u2'>) ]

rule Generate_recepient:
    // private recepient key
    [ Fr(~a), Fr(~b) ]
  --[Only_one_r()]->
    [ !SkPair(<~a, ~b, 'r'>), !PkPair(<pk(~a), pk(~b), 'r'>) ]

rule Generate_trusted_recepient:
    [ Fr(~a), Fr(~b) ]
  --[Only_one_r2()]->
    [ !SkPair(<~a, ~b, 'r2'>), !PkPair(<pk(~a), pk(~b), 'r2'>) ]

rule Get_receive_address:
    // public a user address
    [ !PkPair(<pka, pkb, nonce>) ]
  -->
    [ Out( <pka, pkb, nonce> ) ]



/*
====================================================
=                                                  =
=                  Get utxo                        =
=                                                  =
====================================================
*/
//先给用户发送一笔交易，代替tx/4项函数，收到这笔交易的用户A会生成一个真的环签名和utxo，

rule Generate_first_tx_to_u1:
    // no input means doesn't need signature
    [ !PkPair(<pka, pkb, 'u1'>), Fr(~r), Fr(~amount), Fr(~fakesign)]
  -->
    [ Firsttx(deskey(~r, pka, pkb), ~amount, R(~r), ~fakesign, 'u1') ]

rule Generate_first_tx_to_u2:
    [ !PkPair(<pka, pkb, 'u2'>), Fr(~r), Fr(~amount), Fr(~fakesign)]
  -->
    [ Firsttx(deskey(~r, pka, pkb), ~amount, R(~r), ~fakesign, 'u2') ]

// u1 and u2 verify and get his own utxo(common transaction, output to public channel as a term)
rule Recepient_verify_each_output:
    let mytx = tx(dk, m, R(r), fakesign) in
    [ Firsttx(dk, m, R(r), fakesign, id), !SkPair(<a, b, id>) ]
  --[ Eq(deskeyver(dk, a, R(r)), true) ]->
    [ ReceiveTransaction(id, mytx), Out(mytx) ]

// u1 use some of the first_tx to make 'trusted transaction'(private trusted transaction, generated as a fact)
rule U1_verify_trusted_tx:
    let mytx = tx(dk, m, R(r), fakesign) in
    [ Firsttx(dk, m, R(r), fakesign, 'u1'), !SkPair(<a, b, 'u1'>) ]
  --[ Eq(deskeyver(dk, a, R(r)), true) ]->      // verify valid Firsttx which was sent to u1
    [ ReceiveTrustedTransaction('u1', mytx) ]



/*
===================================================================
=                                                                 =
=                 Generate trusted transaction                    =
=                                                                 =
===================================================================
*/
rule Generate_trusted_transaction:
    // u1 spend trusted_tx as utxo, pay r2 a sum of money
    // Thus, this pay was generated by u1 himself, which could be trusted not to be polluted by adversary
    let
      x = spendkey(a, trustR, b)
      newdk = deskey(~r, pka, pkb)
      rsignature = rsign(x, trustdk, trustdk, dk, trustm)
      pay = tx(newdk, ~amount, R(~r), rsignature)
    in
    [
      ReceiveTrustedTransaction('u1', tx(trustdk, trustm, trustR, trustsign)), !SkPair(<a, b, 'u1'>),
      ReceiveTransaction('u1', tx(dk, m, otherR, signature)),            // use another transaction started by u1 for obfuscation
      !PkPair(<pka, pkb, 'r2'>), Fr(~r), Fr(~amount)
    ]
  -->
    [ TrustedTransaction(pay) ]

/*
========================================================
=                                                      =
=               u1 start a transaction                 =
=                                                      =
========================================================
*/
    // 首先使用let申明了用户r接收交易的一次性地址newdk；
    // 前置条件是用户u1收到其他用户给自己发送的交易，
    // 是u1向r转账的前置条件；
    // Neq强调了在其他用户向u1转账时地址dk的唯一性，SendOut表示用户u1向r发送交易的动作，两者对安全属性的构建和约束的构建产生作用；
    // 后置事实描述了以上行为发生后的系统状态，即向一次性地址newdk发送消息。

rule Generate_signature_and_spend_u1:
       
    let
      x  = spendkey(a, oldR, b)
      rsignature = rsign(x, dk, dk, diff(trustdk, otherdk), m)
      // pay = tx(newdk, ~amount, R(~r), rsignature)
    in
    [
      ReceiveTransaction('u1', tx(dk, m, oldR, oldsign)),
      In(tx(otherdk, otherm, otherR, othersign)),
      TrustedTransaction(tx(trustdk, trustm, trustR, trustsign)),
      !PkPair(<pka, pkb, 'r'>), !SkPair(<a, b, 'u1'>), Fr(~r), Fr(~amount)
    ]
  --[Neq(dk, otherdk)]->
    [ Out( rsignature ) ]




// lemma

// no lemma to be proved in the equivalence mode

end